2. 问题解答

- **哪些寄存器保存函数的参数？例如，在`main`对`printf`的调用中，哪个寄存器保存13？**
  
  前八个函数参数依次存放在 `a0` 到 `a7` 寄存器中。在 `main` 函数对 `printf` 的调用中，参数13保存在 `a2` 寄存器中，参数12（即 `f(8) + 1` 的结果）保存在 `a1` 寄存器中。
  

---

- **`main`的汇编代码中对函数`f`的调用在哪里？对`g`的调用在哪里?(提示：编译器可能会将函数内联）**
  
  在`main`函数中，并没有直接调用`f`和`g`的指令，而是直接对寄存器`a1`进行了加载指令：
  
  ```c
  26:    45b1                    li    a1,12              // 将12加载到a1寄存器
  ```
  

        这意味着`main`函数中对`f`和`g`的调用已被内联，因此没有显式的调用指令。`f`和`g`的代码被直接插入到了`main`函数中，进行计算。

---

- **`printf`函数位于哪个地址？**
  
  `34: 612080e7 jalr 1554(ra) // 跳转到printf函数并保存返回地址`因此地址为ra+1554
  

---

- **在`main`中`printf`的`jalr`之后的寄存器`ra`中有什么值？**
  
  `jalr`指令位于地址`0x34`。`jalr`执行后，`ra`将保存`0x34 + 4`的值，即`0x38`，因为RISC-V指令长度固定为4字节。所以，在`main`函数中调用`printf`函数后，`ra`寄存器中的值是`0x38`。
  

---

- **运行以下代码，指出程序的输出，输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把`i`设置成什么？是否需要将`57616`更改为其他值？**

```c
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
```

小端的输出结果为`He110 World`,这个代码中的 `i` 在小端存储下表示为72 6C 64 00 （从低字节到高字节）,在大端存储下表示为：00 64 6C 72 （从高字节到低字节）,为了让输出结果保持不变，我们需要将 `i` 重新设置为在大端存储下与原来在小端存储相同的数值。

因此，在大端存储下，需要将 `i` 设置为 `0x726C6400`,57616不需要变化

- **在下面的代码中，“`y=`”之后将打印什么（注：答案不是一个特定的值）？为什么会发生这种情况？**

```c
printf("x=%d y=%d", 3);
```

`printf()`会从`a2`寄存器中读取第二个参数作为`y`的值，寄存器`a2`中存储的值是无法预估的。